/********************************************************/
/*                     3D.c                             */
/********************************************************/
/* Visualisation en 3D de système multicontacts         */
/* Developpé par Fortin                                 */
/* Modifié le 6/03/05                                   */
/********************************************************/

/* inclusion des fichiers d'en-tete Glut */
#include <GL/glut.h>
#include <cstdlib>
#include <cstdio>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <iostream>
#include <cmath>
#include <sys/time.h> 
#include <sys/resource.h> 
#include <string.h>
#include <unistd.h>

#include "gl2ps.h"

using namespace std;

#define MAXSPHERE 1000000
#define MAXSUBD 250
#define MAXVOXEL 27000000
#define MAXELF 100000
#define MAXPAROI 400
#define MAX_PATH_LENGTH 1024
#define LDEBUG 0

// Prototype des fonctions 

void affichage();
void clavier(unsigned char key, int x, int y);
void processSpecialKeys(int key, int x, int y); 
void idle();
void menu(int choice);
void multi();
void reshape(int x,int y);
void mouse(int bouton,int etat,int x,int y);
void mousemotion(int x,int y);
void deffic();
void eval_sphere();
void gener_sphere(float xxi, float yyi, float zzi, float rays);
void setup_illumination();

void writefile(int format, int sort, int options, int nbcol,char *filename,const char *extension);
void sauvegarde(int pas);

// variables 
       
FILE *P_FICHIER; 
char NOM_FICHIER[MAX_PATH_LENGTH];
char NOM_FEPS[40];

const int Nt=5;
const int Np=5;
float views[MAXSUBD][5];

const  double  pi2 = 6.28318530718; 
static float rotation = -60.;
static int nbsphere, nbparoi, nbver;
static int NX, NY, NZ, NTOT;
static int jj;
static float qmaxv, qminv, qmaxh, qminh, qmaxz, qminz;
static float svmmin,svmmax,tracemax,tracemin,sig11max,sig11min,sig22max,sig22min,sig33max,sig33min;
static float sig12max,sig12min,sig13max,sig13min,sig23max,sig23min;
static float sig1max,sig1min,sig2max,sig2min,sig3max,sig3min;
static float dep1max,dep1min,dep2max,dep2min,dep3max,dep3min;
static float svmminv,svmmaxv;
float LIST_N[MAXVOXEL];
float xc[MAXSPHERE],  yc[MAXSPHERE], zc[MAXSPHERE], ray[MAXSPHERE],g,t;
int edge[MAXSPHERE];
int typs[MAXSPHERE];
float coul1[10], coul2[10], coul3[10], vcoulmax[10] ;
float SVM[MAXSPHERE],TRACE[MAXSPHERE],SIG11[MAXSPHERE],SIG22[MAXSPHERE],SIG33[MAXSPHERE];
float SIG12[MAXSPHERE],SIG13[MAXSPHERE],SIG23[MAXSPHERE];
float SIG1[MAXSPHERE],SIG2[MAXSPHERE],SIG3[MAXSPHERE];
float DEP1[MAXSPHERE],DEP2[MAXSPHERE],DEP3[MAXSPHERE];
float vali,tps,maxv,invmaxv,xfx1, xfx2, xfx3, xfx4, yfy1, yfy2, yfy3, yfy4;
float xmin1,xmin2,xmax1,xmax2,ymin1,ymin2,ymax1,ymax2;
float qcjx[MAXPAROI], qcjy[MAXPAROI], qcjz[MAXPAROI];
float qckx[MAXPAROI], qcky[MAXPAROI], qckz[MAXPAROI];
float qclx[MAXPAROI], qcly[MAXPAROI], qclz[MAXPAROI];
float qcmx[MAXPAROI], qcmy[MAXPAROI], qcmz[MAXPAROI];
float xcf[MAXELF][4], ycf[MAXELF][4], zcf[MAXELF][4], VONMISV[MAXELF];


static GLsizei window_w = 0; 
static GLsizei window_h = 0;
static int nfeps = 1 ;
static int incr = 0 ;
char nfeps_str[10];
static int lanime = 0 ;
static int ltype = 0 ;

bool bmove=1;

float X_TOT;
float Y_TOT;
float Z_TOT;

float X_TOT2;
float Y_TOT2;
float Z_TOT2;

static float pcut=0.;
static float angview=70.;
float posrel=0.;
float theta_eye;
float phi_eye;
float rayon;
float x_eye;
float y_eye;
float z_eye;
int x_g;
int x_d;
int y_g;
int y_d;
int click_g;
int click_d;

float dx=0.;
float dy=1.;
float dz=0.;

int type_ver;

char presse;
int anglex,angley,x,y,xold,yold,ntype,ind;


int main ( int argc, char **argv ) 
{  
  // Ouverture fichier 
  deffic();

  // Para sphères
  eval_sphere();

  // initialisation de glut et creation de la fenetre 
  glutInit(&argc, argv);  
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH);  
  glutInitWindowPosition(100,100);
  window_w = 900; 
  window_h = 900;
  glutInitWindowSize(window_w,window_h);
  glutCreateWindow("Visualisation multicor");

  // Initialisation d'OpenGL 
  glClearColor(1,1,1,1);
  glEnable(GL_DEPTH_TEST);
 
  // Parametres "joystick" 
	x_eye = -dx*2.*X_TOT;
	y_eye = -dy*2.*Y_TOT;
	z_eye = -dz*2.*Z_TOT;
	
	jj=1;

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

	rayon=sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye); 
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));

  glutDisplayFunc(affichage);
  glutIdleFunc(idle);
  glutReshapeFunc(reshape);

  glutKeyboardFunc(clavier);
  glutSpecialFunc(processSpecialKeys);
  glutMouseFunc(mouse); 
  glutMotionFunc(mousemotion);

   // enregistrement des fonctions de rappel 

  glutCreateMenu(menu);
  glutAddMenuEntry("[a] Stoppe animation", 1);
  glutAddMenuEntry("[r] Demarrer animation", 2);
  glutAddMenuEntry("[s] Pas a pas", 3);
  glutAddMenuEntry("[f] Format PS ou PDF", 4);
  glutAddMenuEntry("[i] Image", 5);
  glutAddMenuEntry("[v] Video", 6);
  glutAddMenuEntry("[esc] Quit", 7);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
     
    // Entree dans la boucle principale glut 
  glutMainLoop();
  return(0) ;
}  


void processSpecialKeys(int key, int x, int y) {
  
        switch(key){
        case GLUT_KEY_LEFT: {
	// translation //Y <0 si touche v
        x_eye-=0.1*dy*X_TOT;	
        y_eye-=0.1*dz*Y_TOT;	
        z_eye-=0.1*dx*Y_TOT;	

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));	
	break;	  
	}
        case GLUT_KEY_RIGHT : {
	// translation //Y >0 si touche ^
        x_eye+=0.1*dy*X_TOT;	
        y_eye+=0.1*dz*Y_TOT;	
        z_eye+=0.1*dx*Y_TOT;	

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
	break;	  
	}	
        case GLUT_KEY_DOWN : {
        x_eye-=0.1*dz*X_TOT;	
        y_eye-=0.1*dx*Y_TOT;	
        z_eye-=0.1*dy*Y_TOT;	

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
	break;	  
	}	
        case GLUT_KEY_UP : {
        x_eye+=0.1*dz*X_TOT;	
        y_eye+=0.1*dx*Y_TOT;	
        z_eye+=0.1*dy*Y_TOT;		

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
	break;	  
	}	
	}
}


void setup_illumination(){
		
  // Intialise and set lighting parameters
  GLfloat light_pos[] = {-200.*dx,-200.*dy,200.*dz, 1.};
  GLfloat light_ka[] = {0., 0., 0.2, 1.};
  GLfloat light_kd[] = {1., 1., 1., 1.};
  GLfloat light_ks[] = {1., 1., 1., 1.};
  
  glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
  glLightfv(GL_LIGHT0, GL_AMBIENT,  light_ka);
  glLightfv(GL_LIGHT0, GL_DIFFUSE,  light_kd);
  glLightfv(GL_LIGHT0, GL_SPECULAR, light_ks);

  
  // Initialise and set material parameters
  GLfloat material_ka[] = {1.0, 1.0, 1.0, 1.0};
  GLfloat material_kd[] = {0.43, 0.47, 0.54, 1.0};
  GLfloat material_ks[] = {0.33, 0.33, 0.52, 1.0};
  GLfloat material_ke[] = {0.0, 0.0, 0.0, 0.0};
  GLfloat material_se[] = {10.0};

  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,  material_ka);
  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,  material_kd);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,  material_ks);
  glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION,  material_ke);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, material_se);
  
// Smooth shading
glShadeModel(GL_SMOOTH);

//Enable lighting
glEnable (GL_LIGHTING);
glEnable (GL_LIGHT0);

}
  
void affichage(){

float x,y,z;
  
glClear
(
GL_COLOR_BUFFER_BIT |
GL_DEPTH_BUFFER_BIT
); 	//Efface le frame buffer et le Z-buffer
glMatrixMode(GL_MODELVIEW); 	//Choisit la matrice MODELVIEW
glLoadIdentity(); 	//Réinitialise la matrice
gluLookAt(x_eye,y_eye,z_eye,0.,0.,0.,dz,dx,dy);
int i,j,k,l;
i=0;
j=0;
k=0;

if(bmove){

//Dir z
glColor3f(1.,0.,0.);   
GLUquadricObj *pObj;		//definition du pointeur d'objet
pObj = gluNewQuadric();		//creation d'un objet(Retourne 0 si No Memory)
gluQuadricNormals(pObj, GLU_SMOOTH);		//application des normals
glPushMatrix();	
glTranslated((-0.7*X_TOT),(-0.7*Y_TOT),(-0.7*Z_TOT));
gluCylinder(pObj, 1.,1., 0.15*Z_TOT, 10, 10);
glTranslated(0.,0.,0.15*Z_TOT);
glutSolidCone(0.02*Z_TOT, 0.05*Z_TOT, 10, 10);
glPopMatrix();	
gluDeleteQuadric (pObj);		//detruit l'objet


//Dir y
glColor3f(0.,1.,0.);   
GLUquadricObj *pObj2;		//definition du pointeur d'objet
pObj2 = gluNewQuadric();		//creation d'un objet(Retourne 0 si No Memory)
gluQuadricNormals(pObj2, GLU_SMOOTH);		//application des normals
glPushMatrix();	
glTranslated((-0.7*X_TOT),(-0.7*Y_TOT),(-0.7*Z_TOT));
glRotatef(-90,1,0,0);
gluCylinder(pObj2, 1.,1., 0.15*Z_TOT, 10, 10);
glTranslated(0.,0.,0.15*Z_TOT);
glutSolidCone(0.02*Z_TOT, 0.05*Z_TOT, 10, 10);
glPopMatrix();	
gluDeleteQuadric (pObj2);		//detruit l'objet


//Dir x
glColor3f(0.,0.,1.);   
GLUquadricObj *pObj3;		//definition du pointeur d'objet
pObj3 = gluNewQuadric();		//creation d'un objet(Retourne 0 si No Memory)
gluQuadricNormals(pObj3, GLU_SMOOTH);		//application des normals
glPushMatrix();	
glTranslated((-0.7*X_TOT),(-0.7*Y_TOT),(-0.7*Z_TOT));
glRotatef(90,0,1,0);
gluCylinder(pObj3, 1.,1., 0.15*Z_TOT, 10, 10);
glTranslated(0.,0.,0.15*Z_TOT);
glutSolidCone(0.02*Z_TOT, 0.05*Z_TOT, 10, 10);
glPopMatrix();	
gluDeleteQuadric (pObj3);	

}
else{

glColor3f(0.0f,0.0f,0.0f);

glMatrixMode(GL_PROJECTION);
glPushMatrix();
glLoadIdentity();
gluOrtho2D(0.0, window_w, 0.0, window_h);
glMatrixMode(GL_MODELVIEW);
glPushMatrix();
glLoadIdentity();

if(dx==1){
char txt[32] = "Plan yx" ;
glRasterPos2f(0.1*window_w,0.1*window_h);
gl2psText(txt, "Helvetica", 24);

int len = (int) strlen(txt);
for (int i = 0; i < len; i++){ glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, txt[i] ); }
}
else if(dy==1){
char txt[32] = "Plan xz" ;
glRasterPos2f(0.1*window_w,0.1*window_h);
gl2psText(txt, "Helvetica", 24);

int len = (int) strlen(txt);
for (int i = 0; i < len; i++){ glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, txt[i] ); }
}
else if(dz==1){
char txt[32] = "Plan yx" ;
glRasterPos2f(0.1*window_w,0.1*window_h);
gl2psText(txt, "Helvetica", 24);

int len = (int) strlen(txt);
for (int i = 0; i < len; i++){ glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, txt[i] ); }
}

char txt0[32] = "Pos. rel. du plan : " ;
char txt1[32];
sprintf(txt1,"%f",posrel);
strcat(txt0,txt1);

glRasterPos2f(0.1*window_w,0.06*window_h);
gl2psText(txt0, "Helvetica", 24);

int len0 = (int) strlen(txt0);
for (int i = 0; i < len0; i++){ glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, txt0[i] ); }

glMatrixMode(GL_MODELVIEW);
glPopMatrix();
glMatrixMode(GL_PROJECTION);
glPopMatrix();

}

  glColor3f(0.,0.,0.);  
    
  // Draw paroi
  //for (i=1;i<=nbparoi;i++ ) 
  //{ 
  // glBegin(GL_LINE_LOOP);
  //  x = qcjx[i]-X_TOT/2. ;
  //  y = qcjy[i]-Y_TOT/2.  ;
  //  z = qcjz[i]-Z_TOT/2. ;
  //  glVertex3f(x,y,z);
  //  x = qckx[i]-X_TOT/2.  ;
  //  y = qcky[i]-Y_TOT/2. ;
  //  z = qckz[i]-Z_TOT/2. ;
  //  glVertex3f(x,y,z);
  //  x = qclx[i]-X_TOT/2.  ;
  //  y = qcly[i]-Y_TOT/2. ;
  //  z = qclz[i]-Z_TOT/2. ;
  //  glVertex3f(x,y,z);
  //  x = qcmx[i]-X_TOT/2.  ;
  //  y = qcmy[i]-Y_TOT/2. ;
  //  z = qcmz[i]-Z_TOT/2. ;
  //  glVertex3f(x,y,z);
  //  glEnd();
 // }



if(ntype==4){ 
  
		// Draw sphere 

		int ii,jj;
		float xxi,yyi,zzi;
		float rays;

	//	

			for (i=1;i<=nbsphere;i++ )
			{

				if(edge[i]==0){					

					rays=ray[i];

                                        if(typs[i]==2){
					GLfloat Rouge[] = {0.5,0.5,0.5, 1.};

					glColor4fv(Rouge); 

					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
					xxi=xc[i]/1e10-X_TOT/2.;
					yyi=yc[i]/1e10-Y_TOT/2.;
					zzi=zc[i]/1e10-Z_TOT/2.;

					gener_sphere(xxi,yyi,zzi,rays);

					//Disable lighting
					glDisable(GL_BLEND);

                                        }else if(typs[i]<2){

					GLfloat Rouge[] = {0.5,0.5,0.5, 0.04};

					glColor4fv(Rouge); 

					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
					xxi=xc[i]-X_TOT/2.;
					yyi=yc[i]-Y_TOT/2.;
					zzi=zc[i]-Z_TOT/2.;

					gener_sphere(xxi,yyi,zzi,rays);

					//Disable lighting
					glDisable(GL_BLEND);

                                        }

				} //fin if

			} //fin for

}else if(ntype==3){
maxv = (svmmaxv-svmminv) ;
int nbe;

i=0;
j=0;
k=0;
float cH=X_TOT;
float cF=1.;

glColor3f(0.,0.,0.);
// Box
	glBegin(GL_LINE_LOOP);
	glVertex3i((i-cH/2)/cF, (j-cH/2)/cF,(k-cH/2)/cF);     
	glVertex3i((i+cH-cH/2)/cF,  (j-cH/2)/cF,(k-cH/2)/cF);      
	glVertex3i((i+cH-cH/2)/cF,  (j-cH/2)/cF,(k+cH-cH/2)/cF);     
	glVertex3i((i-cH/2)/cF, (j-cH/2)/cF,(k+cH-cH/2)/cF);    
      	glEnd();
	// BACK
	glBegin(GL_LINE_LOOP);
	glVertex3i((i-cH/2)/cF, (j+cH-cH/2)/cF,(k-cH/2)/cF);     
	glVertex3i((i+cH-cH/2)/cF,  (j+cH-cH/2)/cF,(k-cH/2)/cF);      
	glVertex3i((i+cH-cH/2)/cF,  (j+cH-cH/2)/cF,(k+cH-cH/2)/cF);     
	glVertex3i((i-cH/2)/cF, (j+cH-cH/2)/cF,(k+cH-cH/2)/cF);    
      	glEnd();      
	// LEFT
	glBegin(GL_LINE_LOOP);
	glVertex3i((i-cH/2)/cF, (j+cH-cH/2)/cF,(k-cH/2)/cF);     
	glVertex3i((i-cH/2)/cF,  (j-cH/2)/cF,(k-cH/2)/cF);      
	glVertex3i((i-cH/2)/cF,  (j-cH/2)/cF,(k+cH-cH/2)/cF);     
	glVertex3i((i-cH/2)/cF, (j+cH-cH/2)/cF,(k+cH-cH/2)/cF);    
      	glEnd();
	// RIGHT
	glBegin(GL_LINE_LOOP);
	glVertex3i((i+cH-cH/2)/cF, (j+cH-cH/2)/cF,(k-cH/2)/cF);     
	glVertex3i((i+cH-cH/2)/cF,  (j-cH/2)/cF,(k-cH/2)/cF);      
	glVertex3i((i+cH-cH/2)/cF,  (j-cH/2)/cF,(k+cH-cH/2)/cF);     
	glVertex3i((i+cH-cH/2)/cF, (j+cH-cH/2)/cF,(k+cH-cH/2)/cF);    
      	glEnd();   	
	// BOTTOM
	glBegin(GL_LINE_LOOP);
	glVertex3i((i-cH/2)/cF, (j-cH/2)/cF,(k-cH/2)/cF);     
	glVertex3i((i+cH-cH/2)/cF,  (j-cH/2)/cF,(k-cH/2)/cF);      
	glVertex3i((i+cH-cH/2)/cF,  (j+cH-cH/2)/cF,(k-cH/2)/cF);     
	glVertex3i((i-cH/2)/cF, (j+cH-cH/2)/cF,(k-cH/2)/cF);    
      	glEnd();
	// UP
	glBegin(GL_LINE_LOOP);
	glVertex3i((i-cH/2)/cF, (j-cH/2)/cF,(k+cH-cH/2)/cF);     
	glVertex3i((i+cH-cH/2)/cF,  (j-cH/2)/cF,(k+cH-cH/2)/cF);      
	glVertex3i((i+cH-cH/2)/cF,  (j+cH-cH/2)/cF,(k+cH-cH/2)/cF);     
	glVertex3i((i-cH/2)/cF, (j+cH-cH/2)/cF,(k+cH-cH/2)/cF);    
      	glEnd(); 

j=jj;

//map

for(k=1;k<=NZ;k++){ 
  for(i=1;i<=NX;i++){

    nbe=(k-1)*NX*NY+(j-1)*NX+(i-1)+1;
      
	    vali=0. ; 
		if((svmmaxv-svmminv)>1.e-12)
		{
		vali=(svmmaxv-LIST_N[nbe])/maxv ;
		}		  


    glColor3f(1.,vali,0.);  
    
    glBegin(GL_QUADS);

	glVertex3f((X_TOT/NX)*i-X_TOT/2., (Y_TOT/NY)*(j-0.5)-Y_TOT/2.,(Z_TOT/NZ)*(k-1)-Z_TOT/2.);
	glVertex3f((X_TOT/NX)*(i-1)-X_TOT/2., (Y_TOT/NY)*(j-0.5)-Y_TOT/2.,(Z_TOT/NZ)*(k-1)-Z_TOT/2.);
	glVertex3f((X_TOT/NX)*(i-1)-X_TOT/2., (Y_TOT/NY)*(j-0.5)-Y_TOT/2.,(Z_TOT/NZ)*k-Z_TOT/2.);
	glVertex3f((X_TOT/NX)*i-X_TOT/2., (Y_TOT/NY)*(j-0.5)-Y_TOT/2.,(Z_TOT/NZ)*k-Z_TOT/2.);
	
    glEnd(); 	

  }    
}

    glColor3f(0.,0.,0.); 
    glBegin(GL_LINE_LOOP);
    
	glVertex3f(-X_TOT/2.,(Y_TOT/NY)*(j-0.5)-Y_TOT/2,-Z_TOT/2.);
	glVertex3f(X_TOT/2.,(Y_TOT/NY)*(j-0.5)-Y_TOT/2,-Z_TOT/2.);
	glVertex3f(X_TOT/2.,(Y_TOT/NY)*(j-0.5)-Y_TOT/2,Z_TOT/2.);
	glVertex3f(-X_TOT/2.,(Y_TOT/NY)*(j-0.5)-Y_TOT/2,Z_TOT/2.);
	
    glEnd();       	
		
    double coordx, coordy, deltax, deltay ;
    deltax = window_w/40. ; deltay = window_h/400. ;
    coordx = 4.27*window_w/5.; coordy = 0.65*window_h ;
    
   
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D(0.0, window_w, 0.0, window_h);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

                        //Colorbar
			for (k=1;k<=100;k++ ) 
			{
			glColor3f(1.,1.-k/100.,0.) ;
			x=coordx ;
			y=coordy + (k-1)*deltay ;

			glPolygonMode(GL_FRONT, GL_FILL);
			glBegin(GL_POLYGON);
			glVertex2f (x, y) ;
			glVertex2f (x+deltax, y) ;
			glVertex2f (x+deltax, y+deltay) ;
			glVertex2f (x, y+deltay) ;
			glVertex2f (x, y) ;
			glEnd();
			}

			glLineWidth(2.0);
			glColor3f(0.0f,0.0f,0.0f);
			glBegin(GL_LINE_LOOP); 
			glVertex2f(coordx,coordy) ;
			glVertex2f(coordx+deltax,coordy) ;
			glVertex2f(coordx+deltax,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy) ;
			glEnd();
			
			
			//Colorbar values
			glColor3f(0.0f,0.0f,0.0f);
			float fVal ;
			fVal = svmminv;
			char cVal[32] ;
			sprintf(cVal,"%.2E",fVal) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy);
			gl2psText(cVal, "Helvetica", 24);

			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }

        	        glColor3f(0.0f,0.0f,0.0f);
			fVal = svmmaxv;
			sprintf(cVal,"%.2E",fVal) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy+95.*deltay);
			gl2psText(cVal, "Helvetica", 24);

			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }
		    	  
			//Title
			glRasterPos2f(4.7*coordx/5., 0.928*window_h);			
			const char * unite = "Contr. VMises (Pa)";

			glColor3f(0.f,0.f,0.f) ;
			gl2psText(unite, "Helvetica", 36);

			for (int i = 0; i < (int) strlen(unite); i++){
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, unite[i] );
			}

  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();

}
else if(ntype==2){
     maxv = (svmmaxv-svmminv) ;
 
	  for (i=1;i<=nbver;i++ )
	  {
		  
		vali=0. ; 
		if((svmmaxv-svmminv)>1.e-12)
		{
		vali=(svmmaxv-VONMISV[i])/maxv ;
		}

if(vali<2){
	
   if(type_ver==2){  //pri6
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glEnable(GL_POLYGON_OFFSET_FILL);
	glPolygonOffset(1.0f, 1.0f);

		glBegin(GL_TRIANGLES);
			glColor3f(1.,vali,0.);
			glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
			glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
			glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);

			glColor3f(1.,vali,0.);
			glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
			glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
			glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);	
		glEnd();
		
		glBegin(GL_QUADS);	
			glColor3f(1.,vali,0.);
			glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
			glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
			glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
			glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
			
			glColor3f(1.,vali,0.);
			glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
			glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);
			glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);
			glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);			
			
			glColor3f(1.,vali,0.);
			glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
			glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);
			glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);
			glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);	
			
								
		glEnd();			
		
		glDisable(GL_POLYGON_OFFSET_FILL);

	
	
	   }else if(type_ver==1){ //tet4
		
		
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		glEnable(GL_POLYGON_OFFSET_FILL);
		glPolygonOffset(1.0f, 1.0f);

			glBegin(GL_TRIANGLES);
				glColor3f(1.,vali,0.);
				glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
				glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][1]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
				glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][2]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);

				glColor3f(1.,vali,0.);
				glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
				glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][1]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
				glVertex3f(xcf[i][3]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][3]-Z_TOT/2.);
							
				glColor3f(1.,vali,0.);
				glVertex3f(xcf[i][0]-X_TOT/2.,ycf[i][0]-Y_TOT/2.,zcf[i][0]-Z_TOT/2.);
				glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][2]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);
				glVertex3f(xcf[i][3]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][3]-Z_TOT/2.);
				
				glColor3f(1.,vali,0.);
				glVertex3f(xcf[i][1]-X_TOT/2.,ycf[i][1]-Y_TOT/2.,zcf[i][1]-Z_TOT/2.);
				glVertex3f(xcf[i][2]-X_TOT/2.,ycf[i][2]-Y_TOT/2.,zcf[i][2]-Z_TOT/2.);
				glVertex3f(xcf[i][3]-X_TOT/2.,ycf[i][3]-Y_TOT/2.,zcf[i][3]-Z_TOT/2.);		
										
			glEnd();
			glDisable(GL_POLYGON_OFFSET_FILL);
			
		 }	
		
	 }
	 
	  
      }

	double coordx, coordy, deltax, deltay ;
	deltax = window_w/40. ; deltay = window_h/400. ;
	coordx = 4.27*window_w/5.; coordy = 0.65*window_h ;

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D(0.0, window_w, 0.0, window_h);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

                        //Colorbar
			for (k=1;k<=100;k++ ) 
			{
			glColor3f(1.,1.-k/100.,0.) ;
			x=coordx ;
			y=coordy + (k-1)*deltay ;

			glPolygonMode(GL_FRONT, GL_FILL);
			glBegin(GL_POLYGON);
			glVertex2f (x, y) ;
			glVertex2f (x+deltax, y) ;
			glVertex2f (x+deltax, y+deltay) ;
			glVertex2f (x, y+deltay) ;
			glVertex2f (x, y) ;
			glEnd();
			}

			glLineWidth(2.0);
			glColor3f(0.0f,0.0f,0.0f);
			glBegin(GL_LINE_LOOP); 
			glVertex2f(coordx,coordy) ;
			glVertex2f(coordx+deltax,coordy) ;
			glVertex2f(coordx+deltax,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy) ;
			glEnd();
			
                        //Colorbar VALUES
			glColor3f(0.0f,0.0f,0.0f);
			float fVal ;
			fVal = svmminv;
			char cVal[32] ;
			sprintf(cVal,"%.2E",fVal) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy);
			gl2psText(cVal, "Helvetica", 24);
			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }

          	        glColor3f(0.0f,0.0f,0.0f);
			fVal = svmmaxv;
			sprintf(cVal,"%.2E",fVal) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy+95.*deltay);
			gl2psText(cVal, "Helvetica", 24);
			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }

    
			//Title
			glRasterPos2f(4.7*coordx/5., 0.928*window_h);			
			const char * unite = "Contr. VMises (Pa)";

			glColor3f(0.f,0.f,0.f) ;
			gl2psText(unite, "Helvetica", 36);

			for (int i = 0; i < (int) strlen(unite); i++){
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, unite[i] );
			}
	  
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();

  }   
else if(ntype==1){

	 if(ltype==0) {
         invmaxv = ((svmmax-svmmin)<=1.e-12)?0.:(1./(svmmax-svmmin)) ;
         }
	 else if(ltype==1) {
	 invmaxv = ((sig11max-sig11min)<=1.e-12)?0.:(1./(sig11max-sig11min)) ;
	 }
	 else if(ltype==2) {
         invmaxv = ((sig22max-sig22min)<=1.e-12)?0.:(1./(sig22max-sig22min)) ;
         }
	 else if(ltype==3) {
         invmaxv = ((sig33max-sig33min)<=1.e-12)?0.:(1./(sig33max-sig33min)) ;
         }	
	 else if(ltype==4) {
	 invmaxv = ((sig1max-sig1min)<=1.e-12)?0.:(1./(sig1max-sig1min)) ;
	 }
	 else if(ltype==5) {
         invmaxv = ((sig2max-sig2min)<=1.e-12)?0.:(1./(sig2max-sig2min)) ;
         }
	 else if(ltype==6) {
         invmaxv = ((sig3max-sig3min)<=1.e-12)?0.:(1./(sig3max-sig3min)) ;
         }	
	 else if(ltype==7) {
	 invmaxv = ((sig12max-sig12min)<=1.e-12)?0.:(1./(sig12max-sig12min)) ;
	 }
	 else if(ltype==8) {
         invmaxv = ((sig13max-sig13min)<=1.e-12)?0.:(1./(sig13max-sig13min)) ;
         }
	 else if(ltype==9) {
         invmaxv = ((sig23max-sig23min)<=1.e-12)?0.:(1./(sig23max-sig23min)) ;
         }	
	 else if(ltype==10) {
         invmaxv = ((tracemax-tracemin)<=1.e-12)?0.:(1./(tracemax-tracemin)) ;
         }	
 

		// Draw sphere 

			int ii,jj;
			float xxi,yyi,zzi;
			float rays;


					for (i=1;i<=nbsphere;i++ )
					{
					   if(edge[i]==0){	

						if(ltype==0)
						{
							vali=invmaxv*(svmmax-SVM[i]);
						}		
						else if(ltype==1)
						{
							vali=invmaxv*(sig11max-SIG11[i]);
						}		
						else if(ltype==2)
						{
							vali=invmaxv*(sig22max-SIG22[i]);
						}   		
						else if(ltype==3)
						{
							vali=invmaxv*(sig33max-SIG33[i]);
						}   
						else if(ltype==4)
						{
							vali=invmaxv*(sig1max-SIG1[i]);
						}   		
						else if(ltype==5)
						{
							vali=invmaxv*(sig2max-SIG2[i]);
						}   			
						else if(ltype==6)
						{
							vali=invmaxv*(sig3max-SIG3[i]);
						}   		
						else if(ltype==7)
						{
							vali=invmaxv*(sig12max-SIG12[i]);
						}   	
						else if(ltype==8)
						{
							vali=invmaxv*(sig13max-SIG13[i]);
						}   		
						else if(ltype==9)
						{
							vali=invmaxv*(sig23max-SIG23[i]);
						}   
						else if(ltype==10)
						{
							vali=invmaxv*(tracemax-TRACE[i]);
						} 
								  
						  GLfloat Colorval[] = {1.,vali,0.,1.};        
						  glColor4fv(Colorval); 
				    
						  glPushMatrix();	
						  glEnable(GL_BLEND);
						  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

						// Methode 0

							rays=ray[i];
							xxi=xc[i]-X_TOT/2.;
							yyi=yc[i]-Y_TOT/2.;
							zzi=zc[i]-Z_TOT/2.;

							gener_sphere(xxi,yyi,zzi,rays);
             					        glDisable(GL_BLEND); 


						} //fin if

					}

		
         //Colorbar+title
		
		
	double coordx, coordy, deltax, deltay ;
	deltax = window_w/40. ; deltay = window_h/400. ;
	coordx = 4.27*window_w/5.; coordy = 0.65*window_h ;


	float fVal,fVal2 ;
        const char * unite;

	if(ltype==0)
	{			
	fVal = svmmin;
	fVal2 = svmmax;
	unite = "Contr. VMises (Pa)";	
	}
	else if(ltype==1)
	{			
	fVal = sig11min;
	fVal2 = sig11max;
	unite = "Contrainte Sig11 (Pa)";	
	}		
	else if(ltype==2)
	{			
	fVal = sig22min;
	fVal2 = sig22max;
	unite = "Contrainte Sig22 (Pa)";	
	}				        
	else if(ltype==3)
	{			
	fVal = sig33min;
	fVal2 = sig33max;
	unite = "Contrainte Sig33 (Pa)";
	}	
	else if(ltype==4)
	{			
	fVal = sig1min;
	fVal2 = sig1max;
	unite = "Contrainte Sig1 (Pa)";
	}		
	else if(ltype==5)
	{			
	fVal = sig2min;
	fVal2 = sig2max;
	unite = "Contrainte Sig2 (Pa)";	
	}				        
	else if(ltype==6)
	{			
	fVal = sig3min;
	fVal2 = sig3max;
	unite = "Contrainte Sig3 (Pa)";
	}		
	else if(ltype==7)
	{			
	fVal = sig12min;
	fVal2 = sig12max;
	unite = "Contrainte Sig12 (Pa)";
	}		
	else if(ltype==8)
	{			
	fVal = sig13min;
	fVal2 = sig13max;
	unite = "Contrainte Sig13 (Pa)";
	}				        
	else if(ltype==9)
	{			
	fVal = sig23min;
	fVal2 = sig23max;
	unite = "Contrainte Sig23 (Pa)";	
	}		
	else if(ltype==10)
	{			
	fVal = tracemin;
	fVal2 = tracemax;
	unite = "Contrainte Hydro. (Pa)";
	}			 
    
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D(0.0, window_w, 0.0, window_w);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

                        //Colorbar
			for (k=1;k<=100;k++ ) 
			{
			glColor3f(1.,1.-k/100.,0.) ;
			x=coordx ;
			y=coordy + (k-1)*deltay ;

			glPolygonMode(GL_FRONT, GL_FILL);
			glBegin(GL_POLYGON);
			glVertex2f (x, y) ;
			glVertex2f (x+deltax, y) ;
			glVertex2f (x+deltax, y+deltay) ;
			glVertex2f (x, y+deltay) ;
			glVertex2f (x, y) ;
			glEnd();
			}

			glLineWidth(2.0);
			glColor3f(0.0f,0.0f,0.0f);
			glBegin(GL_LINE_LOOP); 
			glVertex2f(coordx,coordy) ;
			glVertex2f(coordx+deltax,coordy) ;
			glVertex2f(coordx+deltax,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy) ;
			glEnd();
		   
			//Colorbar values
			char cVal[32] ;
			sprintf(cVal,"%.2E",fVal) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy);
			gl2psText(cVal, "Helvetica", 24);
			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }
			
			sprintf(cVal,"%.2E",fVal2) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy+95.*deltay);
			gl2psText(cVal, "Helvetica", 24);
			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }
		

		        //Title
			glRasterPos2f(4.7*coordx/5., 0.928*window_h);	

			glColor3f(0.f,0.f,0.f) ;
			gl2psText(unite, "Helvetica", 36);

			for (int i = 0; i < (int) strlen(unite); i++){
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, unite[i] );
			}			

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

  }
  else if(ntype==0){ 
  
  if(ltype==0){

        setup_illumination();
  
	// Draw sphere 

	int ii,jj;
	float xxi,yyi,zzi;
	float rays;



		for (i=1;i<=nbsphere;i++ )
		{
			if(edge[i]==0){	

				rays=ray[i];
				xxi=xc[i]-X_TOT/2.;
				yyi=yc[i]-Y_TOT/2.;
				zzi=zc[i]-Z_TOT/2.;

				gener_sphere(xxi,yyi,zzi,rays);


			} //fin if

		}



	//Disable lighting
	glDisable (GL_LIGHTING);
	glDisable (GL_LIGHT0);	

   }
   else{
     
	 if(ltype==1) {
	 invmaxv = ((dep1max-dep1min)<=1.e-12)?0.:(1./(dep1max-dep1min)) ;
	 }
	 else if(ltype==2) {
         invmaxv = ((dep2max-dep2min)<=1.e-12)?0.:(1./(dep2max-dep2min)) ;
         }
	 else if(ltype==3) {
         invmaxv = ((dep3max-dep3min)<=1.e-12)?0.:(1./(dep3max-dep3min)) ;
         }

		// Draw sphere 

		int ii,jj;
		float xxi,yyi,zzi;
		float rays;

				for (i=1;i<=nbsphere;i++ )
				{

					if(edge[i]==0){	

					//visu

					        if(ltype==1)
						{
						vali=invmaxv*(dep1max-DEP1[i]);
						}		
						else if(ltype==2)
						{
						vali=invmaxv*(dep2max-DEP2[i]);
						}   		
						else if(ltype==3)
						{
						vali=invmaxv*(dep3max-DEP3[i]);
						}   
								  

	
					          GLfloat Colorval[] = {1.,vali,0.,1.};
	
						  glColor4fv(Colorval); 
				    
						  glPushMatrix();	
						  glEnable(GL_BLEND);
						  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);


							// Methode 0

							rays=ray[i];
							xxi=xc[i]-X_TOT/2.;
							yyi=yc[i]-Y_TOT/2.;
							zzi=zc[i]-Z_TOT/2.;

							gener_sphere(xxi,yyi,zzi,rays);
						
						        glDisable(GL_BLEND); 

					} //fin if

				}//fin for


	float fVal,fVal2 ;
        const char * unite;

	if(ltype==1)
	{			
	fVal = dep1min;
	fVal2 = dep1max;
	unite = "Deplac. dep1 (Pa)";	
	}
	else if(ltype==1)
	{			
	fVal = dep2min;
	fVal2 = dep2max;
	unite = "Deplac. dep2 (Pa)";	
	}		
	else if(ltype==3)
	{			
	fVal = dep3min;
	fVal2 = dep3max;
	unite = "Deplac. dep3 (Pa)";		
	}

	double coordx, coordy, deltax, deltay ;
	deltax = window_w/40. ; deltay = window_h/400. ;
	coordx = 4.27*window_w/5.; coordy = 0.65*window_h ;

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D(0.0, window_w, 0.0, window_w);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
                        //Colorbar
			for (k=1;k<=100;k++ ) 
			{
			glColor3f(1.,1.-k/100.,0.) ;
			x=coordx ;
			y=coordy + (k-1)*deltay ;

			glPolygonMode(GL_FRONT, GL_FILL);
			glBegin(GL_POLYGON);
			glVertex2f (x, y) ;
			glVertex2f (x+deltax, y) ;
			glVertex2f (x+deltax, y+deltay) ;
			glVertex2f (x, y+deltay) ;
			glVertex2f (x, y) ;
			glEnd();
			}

			glLineWidth(2.0);
			glColor3f(0.0f,0.0f,0.0f);
			glBegin(GL_LINE_LOOP); 
			glVertex2f(coordx,coordy) ;
			glVertex2f(coordx+deltax,coordy) ;
			glVertex2f(coordx+deltax,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy+100.*deltay) ;
			glVertex2f(coordx,coordy) ;
			glEnd();
		   
			//Colorbar values
			char cVal[32] ;
			sprintf(cVal,"%.2E",fVal) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy);
			gl2psText(cVal, "Helvetica", 24);
			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }
			
			sprintf(cVal,"%.2E",fVal2) ;
			cVal[9]='\0'  ;
			glRasterPos2f(coordx+deltax+deltax/6., coordy+95.*deltay);
			gl2psText(cVal, "Helvetica", 24);
			for (k=0;k<=8;k++ ) {
			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,cVal[k]);
                        }
		

		        //Title
			glRasterPos2f(4.7*coordx/5., 0.928*window_h);	

			glColor3f(0.f,0.f,0.f) ;
			gl2psText(unite, "Helvetica", 36);

			for (int i = 0; i < (int) strlen(unite); i++){
			glutBitmapCharacter( GLUT_BITMAP_HELVETICA_18, unite[i] );
			}	
	  
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();

    }

  }
 
 // Axes 
	if(bmove){
	glColor3f(0.,0.,1.);  
	glRasterPos3f(((0.22-0.7)*X_TOT),(-0.7*Y_TOT),(-0.7*Z_TOT));
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,'x');
	glColor3f(0.,1.,0.);  
	glRasterPos3f(((-0.7)*X_TOT),((0.22-0.7)*Y_TOT),(-0.7*Z_TOT));
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,'y');
	glColor3f(1.,0.,0.);  
	glRasterPos3f(((-0.7)*X_TOT),(-0.7*Y_TOT),((0.22-0.7)*Z_TOT));
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,'z');
	}

 //On echange les buffers 
  glFlush();
  glutSwapBuffers();

  if (lanime) multi( ) ; 
}


void sauvegarde(int pas) {
  int opt,i ;
  const char *ext;
  static int format = GL2PS_EPS;
    lanime = 0 ;
    multi() ;
    glutSetWindowTitle("Pas a pas");
    glutPostRedisplay();
    ext = (format == GL2PS_EPS) ? "eps" : "pdf";
    opt = GL2PS_NONE ;
    if (pas%1 == 0) {
    strcpy(NOM_FEPS,get_current_dir_name());
    if (nfeps<10) 
    { strcat(NOM_FEPS, "/IMAGE/image_visu00"); }
    else if (nfeps<100) 
    { strcat(NOM_FEPS, "/IMAGE/image_visu0"); }
    else
    { strcat(NOM_FEPS, "/IMAGE/image_visu"); }
    sprintf(nfeps_str,"%d",nfeps);
    strcat(NOM_FEPS, nfeps_str);
    writefile(format, GL2PS_SIMPLE_SORT, opt, 0, NOM_FEPS, ext);
    printf("GL2PS done... %s \n",NOM_FEPS);
    nfeps++;
    }
    pas=pas+1 ;
    glutTimerFunc(100,sauvegarde,pas++) ;
}

void clavier(unsigned char key, int x, int y){

  int opt;
  const char *ext;
  static int format = GL2PS_EPS;
  switch(key){
  case 'a':
    glutSetWindowTitle("Animation stoppe");
    lanime = 0 ;
    glutIdleFunc(NULL);
    break;
  case 'Q': {
        x_eye-=0.1*dx*X_TOT;
        y_eye-=0.1*dy*Y_TOT;
        z_eye-=0.1*dz*Z_TOT;	

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
     break; }
  case 'q': { 
        x_eye+=0.1*dx*X_TOT;
        y_eye+=0.1*dy*Y_TOT;
        z_eye+=0.1*dz*Z_TOT;	

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
     break; }       
  case 'r':
    cout<<"On redemarre l'animation"<< endl;
    lanime = 1 ;
    glutSetWindowTitle("Animation redemarre");
    glutIdleFunc(idle);
    break;
  case 's':
    cout<<"Pas a pas ... "<< incr << ", " << tps <<endl;
    lanime = 0 ;
    multi() ;
    glutSetWindowTitle("Pas a pas");
    glutPostRedisplay();
    break;
  case 'f':
    format = (format == GL2PS_EPS) ? GL2PS_PDF : GL2PS_EPS;
    printf("Print format changed to '%s'\n",
           (format == GL2PS_EPS) ? "EPS" : "PDF");
    break;  
  case '+':
    jj=jj+1;
    if(jj>NX) jj=NX;
   break;  
  case '-':
    jj=jj-1;
    if(jj<=0) jj=1;
   break;  
  case 'x':
   dx=1.;
   dy=0.;
   dz=0.;

// + remise à 0 

	x_eye = -dx*2.*X_TOT;
	y_eye = -dy*2.*Y_TOT;
	z_eye = -dz*2.*Z_TOT; 

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

        angview=70.;
        glutReshapeWindow(window_w,window_h);
        cout<<"Plan zy"<<endl;

	rayon= sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));

   break;  
   case 'y':
   dx=0.;
   dy=1.;
   dz=0.;

// + remise à 0 

	x_eye = -dx*2.*X_TOT;
	y_eye = -dy*2.*Y_TOT;
	z_eye = -dz*2.*Z_TOT; 

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

        angview=70.;
        glutReshapeWindow(window_w,window_h);
        cout<<"Plan xz"<<endl;

	rayon= sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
   break;
   case 'z':
   dx=0.;
   dy=0.;
   dz=1.;

// + remise à 0 

	x_eye = -dx*2.*X_TOT;
	y_eye = -dy*2.*Y_TOT;
	z_eye = -dz*2.*Z_TOT;

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

        angview=70.;
        glutReshapeWindow(window_w,window_h);
        cout<<"Plan yx"<<endl;

	rayon= sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
   break;
  case 'i':

    ext = (format == GL2PS_EPS) ? "eps" : "pdf";
    opt = GL2PS_NONE ;
    strcpy(NOM_FEPS, get_current_dir_name());
    if (nfeps<10) 
    { strcat(NOM_FEPS, "/IMAGE/image_visu0"); }
    else
    { strcat(NOM_FEPS, "/IMAGE/image_visu"); }
    sprintf(nfeps_str,"%d",nfeps);
    strcat(NOM_FEPS, nfeps_str);
    writefile(format, GL2PS_SIMPLE_SORT, opt, 0, NOM_FEPS, ext);
    printf("GL2PS done... %s \n",NOM_FEPS);
    nfeps++;  
    break; 
  case 'v':
     glutTimerFunc(50,sauvegarde,0) ;
    break;     
  case 'p':
     bmove=0 ;
     cout<<"Mode plan actif"<<endl;

	x_eye = -dx*1.5*X_TOT;
	y_eye = -dy*1.5*Y_TOT;
	z_eye = -dz*1.5*Z_TOT;

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

        angview=92.79;
        glutReshapeWindow(window_w,window_h);

	glutSpecialFunc(NULL);
	glutMouseFunc(NULL); 
	glutMotionFunc(NULL);

	rayon= sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));

    break;   
  case 'P':
     bmove=1 ;
     cout<<"Mode plan desactif"<<endl;

	x_eye = -dx*2.*X_TOT;
	y_eye = -dy*2.*Y_TOT;
	z_eye = -dz*2.*Z_TOT;

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

        angview=70.;

        glutReshapeWindow(window_w,window_h);

	glutSpecialFunc(processSpecialKeys);
	glutMouseFunc(mouse); 
	glutMotionFunc(mousemotion);

	rayon= sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));


    break;     
  case 27: {
	// sortie si touche ESC
	exit(0);break; }
  case 32: {
	// remise à 0 si space
        bmove=1;

	x_eye = -dx*2.*X_TOT;
	y_eye = -dy*2.*Y_TOT;
	z_eye = -dz*2.*Z_TOT;

	x_g=window_w/2;
	y_g=window_h/2;
	x_d=window_w/2;
	y_d=window_h/2;

        angview=70.;
        glutReshapeWindow(window_w,window_h);

        cout<<"Reinitialisation"<<endl;

	rayon= sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));
	
        break;
	}
	case 'C' : { 
        if(!bmove){
        x_eye-=0.1*dx*X_TOT;
        y_eye-=0.1*dy*Y_TOT;
        z_eye-=0.1*dz*Z_TOT;	
        x_eye=dx*x_eye;
        y_eye=dy*y_eye;
        z_eye=dz*z_eye;


	if(x_eye<-dx*1.5*X_TOT) x_eye=-dx*1.5*X_TOT ;
	if(y_eye<-dy*1.5*Y_TOT) y_eye=-dy*1.5*Y_TOT ;
	if(z_eye<-dz*1.5*Z_TOT) z_eye=-dz*1.5*Z_TOT ;

	if(x_eye>-dx*0.5*X_TOT) x_eye=-dx*0.5*X_TOT;
	if(y_eye>-dy*0.5*Y_TOT) y_eye=-dy*0.5*Y_TOT;
	if(z_eye>-dz*0.5*Z_TOT) z_eye=-dz*0.5*Z_TOT;

        posrel=dx*(X_TOT/2.+X_TOT*(1+pcut)+x_eye)/X_TOT+dy*(Y_TOT/2.+Y_TOT*(1+pcut)+y_eye)/Y_TOT+dz*(Z_TOT/2.+Z_TOT*(1+pcut)+z_eye)/Z_TOT;
        angview=dx*180.*2.*atan2(1.05*X_TOT,X_TOT*max(1.,1.-posrel))/3.14159+dy*180.*2.*atan2(1.05*Y_TOT,Y_TOT*max(1.,1.-posrel))/3.14159+dz*180.*2.*atan2(1.05*Z_TOT,Z_TOT*max(1.,1.-posrel))/3.14159;
        glutReshapeWindow(window_w,window_h);

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));

        cout<<"posi view:"<<dx*x_eye+dy*y_eye+dz*z_eye<<", posi plane:"<<posrel<<", angview:"<<angview<<endl;
        }
	break;	  
	}
	case 'c' : { 
        if(!bmove){
        x_eye+=0.1*dx*X_TOT;
        y_eye+=0.1*dy*Y_TOT;
        z_eye+=0.1*dz*Z_TOT;	
        x_eye=dx*x_eye;
        y_eye=dy*y_eye;
        z_eye=dz*z_eye;

	if(x_eye<-dx*1.5*X_TOT) x_eye=-dx*1.5*X_TOT ;
	if(y_eye<-dy*1.5*Y_TOT) y_eye=-dy*1.5*Y_TOT ;
	if(z_eye<-dz*1.5*Z_TOT) z_eye=-dz*1.5*Z_TOT ;

	if(x_eye>-dx*0.5*X_TOT) x_eye=-dx*0.5*X_TOT;
	if(y_eye>-dy*0.5*Y_TOT) y_eye=-dy*0.5*Y_TOT;
	if(z_eye>-dz*0.5*Z_TOT) z_eye=-dz*0.5*Z_TOT;

        posrel=dx*(X_TOT/2.+X_TOT*(1+pcut)+x_eye)/X_TOT+dy*(Y_TOT/2.+Y_TOT*(1+pcut)+y_eye)/Y_TOT+dz*(Z_TOT/2.+Z_TOT*(1+pcut)+z_eye)/Z_TOT;
        angview=dx*180.*2.*atan2(1.05*X_TOT,X_TOT*max(1.,1.-posrel))/3.14159+dy*180.*2.*atan2(1.05*Y_TOT,Y_TOT*max(1.,1.-posrel))/3.14159+dz*180.*2.*atan2(1.05*Z_TOT,Z_TOT*max(1.,1.-posrel))/3.14159;
        glutReshapeWindow(window_w,window_h);

	rayon    = sqrt(x_eye*x_eye+y_eye*y_eye+z_eye*z_eye);
	theta_eye  = dx*atan2(-z_eye,x_eye)+dy*atan2(-x_eye,y_eye)+dz*atan2(-y_eye,z_eye);
	phi_eye= dx*acos((y_eye)/(rayon))+dy*acos((z_eye)/(rayon))+dz*acos((x_eye)/(rayon));

        cout<<"posi view:"<<dx*x_eye+dy*y_eye+dz*z_eye<<", posi plane:"<<posrel<<", angview:"<<angview<<endl;
        }
	break;	  
	}    
	  case '0':
		ltype=0;
		break;     
	  case '1':
		ltype=1;
		break;       
	  case '2':
		ltype=2;
		break;      
	  case '3':
		ltype=3;
		break;         
	  case '4':
		ltype=4;
	        break;    	
	  case '5':
		ltype=5;
	        break;    
	  case '6':
		ltype=6;
	        break; 
	  case '7':
		ltype=7;
	        break;   
	  case '8':
		ltype=8;
	        break;   
	  case '9':
		ltype=9;
	        break;   
	  case '.':
		ltype=10;
	        break;   
 	
  }

}

void eval_sphere(){

float thetap,stheta,sthetap,ctheta,cthetap;
float phip,sphip,cphip;

cthetap=1.;
sthetap=0.;
int numo=0;

	for (thetap = 2*3.141593/Nt; thetap < 2.00001*3.141593; thetap += 2*3.141593/Nt){
		ctheta=cthetap;
		stheta=sthetap;
		cthetap=cos(thetap);
		sthetap=sin(thetap);
		for (phip = 3.14159/Np; phip < 1.00001*3.14159; phip += 3.14159/Np){
			       sphip=sin(phip);
			       cphip=cos(phip);
			      
				views[numo][0]=cphip;
				views[numo][1]=cthetap*sphip;
				views[numo][2]=ctheta*sphip;   
				views[numo][3]=sthetap*sphip;  
				views[numo][4]=stheta*sphip;  
				numo++;
		}

	}
}

void gener_sphere(float xxi, float yyi, float zzi, float rays){

int numo=0;
glBegin(GL_QUAD_STRIP);

	for (int it1 = 0; it1<Nt; it1++){

		glVertex3f(xxi,yyi,zzi+rays);
		glVertex3f(xxi,yyi,zzi+rays);
		for (int it2 = 0; it2<Np; it2++){

			glNormal3f(views[numo][1],views[numo][3],views[numo][0]);
			glVertex3f(xxi+rays*views[numo][2],yyi+rays*views[numo][4],zzi+rays*views[numo][0]);
			glVertex3f(xxi+rays*views[numo][1],yyi+rays*views[numo][3],zzi+rays*views[numo][0]);
			       
			numo++;
		}

	} //fin for

glEnd();

}

void deffic(){

int i ;
/* Première partie : Creer et remplir le fichier */

  cout<<"VISU deplac     num = 0  &  NOM fichier = vdepl "<<endl;
  cout<<"VISU Mises sph  num = 1  &  NOM fichier = vcontr "<<endl;
  cout<<"VISU Mises ver  num = 2  &  NOM fichier = vcontrv "<<endl;
  cout<<"VISU Mises vox  num = 3  &  NOM fichier = vcontrv2 "<<endl;
  cout<<"VISU rupt       num = 4  &  NOM fichier = vdepl2 "<<endl;
  cout<<"Entrez le num VISU :"<<endl;
  cin>>ntype;
  cout<<"Entrez le nom du fichier à lire : "<<endl;
  cin>>NOM_FICHIER;
  P_FICHIER = fopen(NOM_FICHIER, "r");  /* read */

  if (!P_FICHIER) 
    {
     cout<<"Impossible d'ouvrir le fichier"<<endl;
     exit(-1);
    }  
  else
  {
    fscanf(P_FICHIER, "%f %f %f %f %f %f\n", &qmaxv,&qminv,&qmaxh,&qminh,&qmaxz,&qminz);
    Z_TOT2=fabs(qmaxz-qminz);
    Y_TOT2=fabs(qmaxv-qminv);
    X_TOT2=fabs(qmaxh-qminh);
        Z_TOT=100.;
        Y_TOT=100.;
        X_TOT=100.;
    
    
  }
/* Deuxieme partie :  appel de la fonction multi */
  
  multi() ;
}


void idle(){
glutPostRedisplay();
}

void menu(int choice){

  int opt;
  const char *ext;
  static int format = GL2PS_EPS;
  
  switch (choice) {
  case 1:
    cout<<"On stoppe l'animation..."<<endl;
    lanime = 0 ;
    glutSetWindowTitle("Animation stoppe");
    glutIdleFunc(NULL);
    break;
  case 2:
    cout<<"On relance l'animation..."<<endl;
    lanime = 1 ;
    glutSetWindowTitle("Animation demarre");
    glutIdleFunc(idle);
    break;
  case 3:
    cout<<"On relance l'animation... "<<incr<<", "<<tps<<endl;
    glutSetWindowTitle("Pas a pas");
    lanime = 0 ;
    multi() ;
    glutPostRedisplay();
    break;
  case 4:
   format = (format == GL2PS_EPS) ? GL2PS_PDF : GL2PS_EPS;
    printf("Print format changed to '%s'\n",
           (format == GL2PS_EPS) ? "EPS" : "PDF");
    break;    
  case 5:

    opt = GL2PS_OCCLUSION_CULL | GL2PS_DRAW_BACKGROUND;
    ext = (format == GL2PS_EPS) ? "eps" : "pdf";

    strcpy(NOM_FEPS,get_current_dir_name());
    if (nfeps<10) 
    { strcat(NOM_FEPS, "/IMAGE/image_visu00"); }
    else if (nfeps<100) 
    { strcat(NOM_FEPS, "/IMAGE/image_visu0"); }
    else
    { strcat(NOM_FEPS, "/IMAGE/image_visu"); }
    sprintf(nfeps_str,"%d",nfeps);
    strcat(NOM_FEPS, nfeps_str);

    writefile(format, GL2PS_SIMPLE_SORT, opt, 0, NOM_FEPS, ext);

    printf("GL2PS %d.%d.%d done with all images\n",
           GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION);
    nfeps++;
    break;
  case 6:
    cout<<"On sort ..."<<endl;
    exit(1);
    break;
  }

}

void multi(){

int i,ok ;

  incr++ ;
  if (!feof(P_FICHIER)) 
  {
 


 // for (i=1;i<=nbparoi;i++)
  //   {
  //    fscanf(P_FICHIER, "%f %f %f %f %f %f %f %f %f %f %f %f\n", &qcjx[i], &qcjy[i], &qcjz[i],
  //                                                               &qckx[i], &qcky[i], &qckz[i],
  //                                                               &qclx[i], &qcly[i], &qclz[i],
  //                                                               &qcmx[i], &qcmy[i], &qcmz[i]);
  //                                                               
  //  if (LDEBUG) printf( "qc : %f %f %f %f %f %f %f %f %f %f %f %f\n" , qcjx[i], qcjy[i], qcjz[i],
  //                                                                     qckx[i], qcky[i], qckz[i],
  //                                                                     qclx[i], qcly[i], qclz[i],
  //                                                                     qcmx[i], qcmy[i], qcmz[i]); 
  //   }



     if (ntype==0){
	 fscanf(P_FICHIER, "%i %i %f \n", &nbsphere, &nbparoi, &tps);

     for (i=1;i<=nbsphere;i++)
     {
      fscanf(P_FICHIER, "%i %f %f %f %f %f %f %f\n", &edge[i], &xc[i], &yc[i], &zc[i], &ray[i], &DEP1[i], &DEP2[i], &DEP3[i]);
      xc[i]=xc[i]*X_TOT/X_TOT2;
      yc[i]=yc[i]*X_TOT/X_TOT2;
      zc[i]=zc[i]*X_TOT/X_TOT2;        
      ray[i]=ray[i]*X_TOT/X_TOT2;  
     }
     
     fscanf(P_FICHIER, "%f %f\n", &dep1max,&dep1min);
     fscanf(P_FICHIER, "%f %f\n", &dep2max,&dep2min);  
     fscanf(P_FICHIER, "%f %f\n", &dep3max,&dep3min);     
         
     
     }
     else if (ntype==1){
     fscanf(P_FICHIER, "%i %i %f \n", &nbsphere, &nbparoi, &tps);	

     for (i=1;i<=nbsphere;i++)
     {
     fscanf(P_FICHIER, "%i %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f\n", &edge[i], &xc[i], &yc[i], &zc[i], &ray[i], &SVM[i], &TRACE[i], &SIG11[i], &SIG12[i], &SIG13[i], &SIG22[i], &SIG23[i], &SIG33[i], &SIG1[i], &SIG2[i], &SIG3[i]);
      xc[i]=xc[i]*X_TOT/X_TOT2;
      yc[i]=yc[i]*X_TOT/X_TOT2;
      zc[i]=zc[i]*X_TOT/X_TOT2;
      ray[i]=ray[i]*X_TOT/X_TOT2;             
     }
     
     fscanf(P_FICHIER, "%f %f\n", &svmmax,&svmmin);
     fscanf(P_FICHIER, "%f %f\n", &tracemax,&tracemin);
     fscanf(P_FICHIER, "%f %f\n", &sig11max,&sig11min);
     fscanf(P_FICHIER, "%f %f\n", &sig12max,&sig12min);
     fscanf(P_FICHIER, "%f %f\n", &sig13max,&sig13min);          
     fscanf(P_FICHIER, "%f %f\n", &sig22max,&sig22min);   
     fscanf(P_FICHIER, "%f %f\n", &sig23max,&sig23min);                    
     fscanf(P_FICHIER, "%f %f\n", &sig33max,&sig33min);     
     fscanf(P_FICHIER, "%f %f\n", &sig1max,&sig1min);
     fscanf(P_FICHIER, "%f %f\n", &sig2max,&sig2min);  
     fscanf(P_FICHIER, "%f %f\n", &sig3max,&sig3min);         
          
    tracemin=0.;
     
     }    
     else if (ntype==2){
     fscanf(P_FICHIER, "%i %f %i\n", &nbver, &tps,&type_ver);	
		 
     for (i=1;i<=nbver;i++)
     {
      fscanf(P_FICHIER, "%f %f %f %f %f %f %f %f %f %f %f %f %f \n", &xcf[i][0], &ycf[i][0], &zcf[i][0], &xcf[i][1], &ycf[i][1], &zcf[i][1], &xcf[i][2], &ycf[i][2], &zcf[i][2], &xcf[i][3], &ycf[i][3], &zcf[i][3], &VONMISV[i]);
      xcf[i][0]=xcf[i][0]*X_TOT/X_TOT2;
      ycf[i][0]=ycf[i][0]*X_TOT/X_TOT2;
      zcf[i][0]=zcf[i][0]*X_TOT/X_TOT2;  
      xcf[i][1]=xcf[i][1]*X_TOT/X_TOT2;
      ycf[i][1]=ycf[i][1]*X_TOT/X_TOT2;
      zcf[i][1]=zcf[i][1]*X_TOT/X_TOT2;     
      xcf[i][2]=xcf[i][2]*X_TOT/X_TOT2;
      ycf[i][2]=ycf[i][2]*X_TOT/X_TOT2;
      zcf[i][2]=zcf[i][2]*X_TOT/X_TOT2;      
      xcf[i][3]=xcf[i][3]*X_TOT/X_TOT2;
      ycf[i][3]=ycf[i][3]*X_TOT/X_TOT2;
      zcf[i][3]=zcf[i][3]*X_TOT/X_TOT2;                
     }
      
     fscanf(P_FICHIER, "%f %f\n", &svmmaxv,&svmminv);
      
     }
     else if (ntype==3){
     fscanf(P_FICHIER, "%i %i %i %i %f \n", &NX, &NY, &NZ, &NTOT, &tps);	
     if(tps==0) jj=1; 
      
     for (i=1;i<=NTOT;i++)
     {
     fscanf(P_FICHIER, "%f\n", &LIST_N[i]);
     }
     
     fscanf(P_FICHIER, "%f %f\n", &svmmaxv,&svmminv);
     
     }  
     else if (ntype==4){
	 fscanf(P_FICHIER, "%i %i %f \n", &nbsphere, &nbparoi, &tps);

     for (i=1;i<=nbsphere;i++)
     {
      fscanf(P_FICHIER, "%i %f %f %f %f %i\n", &edge[i], &xc[i], &yc[i], &zc[i], &ray[i], &typs[i]);
      xc[i]=xc[i]*X_TOT/X_TOT2;
      yc[i]=yc[i]*X_TOT/X_TOT2;
      zc[i]=zc[i]*X_TOT/X_TOT2;  
          ray[i]=ray[i]*X_TOT/X_TOT2;        
     }
     
     }      
     
           
  
  } 
  else
  {
    fclose(P_FICHIER);
    incr = 0 ;
    P_FICHIER = fopen(NOM_FICHIER, "r");  
    fscanf(P_FICHIER, "%f %f %f %f %f %f \n", &qmaxv,&qminv,&qmaxh,&qminh,&qmaxz,&qminz);
    lanime = 0 ;
    tps=0.;
  }

}


void reshape(int x, int y)
{

float w = (float) x;
float h = (float) y;	
	
glViewport(0, 0, (GLsizei) x, (GLsizei) y);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
     
gluPerspective(
angview,
1,
1.*(dx*X_TOT*(1.+pcut)+dy*Y_TOT*(1.+pcut)+dz*Z_TOT*(1.+pcut)),
10.*(dx*X_TOT*(1.+pcut)+dy*Y_TOT*(1.+pcut)+dz*Z_TOT*(1.+pcut))
);	//Pour les explications, lire le tutorial sur OGL et win
  
  	glMatrixMode(GL_MODELVIEW); 	//Optionnel


}


void writefile(int format, int sort, int options, int nbcol,
               char *filename, const char *extension){
       
FILE *fp;
  char file[256];
  int state = GL2PS_OVERFLOW, buffsize = 0;
  GLint viewport[4];

  strcpy(file, filename);
  strcat(file, ".");
  strcat(file, extension);

  viewport[0] = 0;
  viewport[1] = 0;
  viewport[2] = window_w;
  viewport[3] = window_h;
 
  fp = fopen(file, "wb");

  if(!fp){
    printf("Unable to open file %s for writing\n", file);
    exit(1);
  }

  printf("Saving image to file %s... ", file);
  fflush(stdout);

  while(state == GL2PS_OVERFLOW){
    buffsize += 1024*1024;
    gl2psBeginPage(file, "test", viewport, format, sort, options,
                   GL_RGBA, 0, NULL, nbcol, nbcol, nbcol, 
                   buffsize, fp, file);
    affichage();
    state = gl2psEndPage();
  }

  fclose(fp);

  printf("Done!\n");
  fflush(stdout);       
}
	
     
	void mouse(int button, int state,int x,int y)
	{
	switch(button){
	case GLUT_LEFT_BUTTON:
	if(state==GLUT_DOWN){
	click_g = 1;
	x_g     = x;
	y_g     = window_h-y;
	}
	break;
	case GLUT_MIDDLE_BUTTON:
	break;
	default:
	if(state==GLUT_DOWN){
	click_d = 1;
	x_d     = x;
	y_d     = window_h-y;
	
	theta_eye+= (3.14159/12.*(((float) x_d)-(((float) window_h)/2.))/(((float) window_h)/2.));
	phi_eye-= (3.14159/12.*(((float) y_d)-(((float) window_h)/2.))/(((float) window_h)/2.));
	if(theta_eye>3.14159) theta_eye-=(2.*3.14159);
	if(phi_eye>3.14159) phi_eye=(2.*3.14159)-phi_eye;
	if(theta_eye<-3.14159) theta_eye+=(2.*3.14159); 
	if(phi_eye<0) phi_eye=-phi_eye ;

 	x_eye = dx*rayon*sin(phi_eye)*cos(theta_eye)-dy*rayon*sin(phi_eye)*sin(theta_eye)+dz*rayon*cos(phi_eye);    
	y_eye = dx*rayon*cos(phi_eye)+dy*rayon*sin(phi_eye)*cos(theta_eye)-dz*rayon*sin(phi_eye)*sin(theta_eye);
	z_eye = -dx*rayon*sin(phi_eye)*sin(theta_eye)+dy*rayon*cos(phi_eye)+dz*rayon*sin(phi_eye)*cos(theta_eye);

	  
	}  
	break;
	}
	}       



  void mousemotion(int x,int y)
  {

  }

